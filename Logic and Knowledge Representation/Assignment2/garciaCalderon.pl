% Assignment 2
% by Saul Garcia
% working_directory(CWD, '/Users/saulgarcia/Dropbox/Maestria/DMKM/Courses/SEM1/Logic/Assignments/A2/').
% [garciaCalderon].

%Prolog programming

%Exercise 5 Basic Matrix operations

%1. size(M, NbRows, NbCols)
%Input: size([[1,2],[3,4],[5,6]], NbRows, NbCols).
%output:NbRows = 3, NbCols = 2;
%Explanation: First length_of proves the validity of the matrix and size brings the number of rows with length and the columns with maplist.

length_of(N, Ls) :-
   length(Ls, N).

size(L, R, C) :-
   length(L, R),
   maplist(length_of(C), L).


%2. rowI(M, I, RI)
%Input rowI([[1,2],[3,4],[5,6]], 2, RI).
%output:RI = [3,4];
%Explanation: With a counter it reduces the number of heads until the head is the desired row number.

rowI([H|_],1,H):-!.
rowI([_|T],I,X) :-
    I1 is I-1,
    rowI(T,I1,X).
	

%3. columnJ(M, J, CJ)
%Input columnJ([[1,2],[3,4],[5,6]], 1, CJ).
%output:CJ = [1,3,5];
%Explanation: Utilizes row to bring that element on each row, making the column.

columnJ([],_,[]).
columnJ([H|T], I, [R|X]):-
	rowI(H, I, R), 
	columnJ(T,I,X).
 
%4. product(M1, M2, R)
%Input product([[1,2],[3,4],[5,6]], [[1,1,1],[1,1,1]], M).
%output M = [[3, 3, 3], [7, 7, 7], [11, 11, 11]];
%Explanation:
%mult do list multiplication returning a scalar
%row_mult Append the whole multiplications of a row
%product appends the rows generated by with row_mult.
%In order to achieve this, the previous codes were needed.

mult([A|As], [B|Bs], Z) :-
    mult(As, Bs, SP),
    Z is SP + A*B.
mult([], [], 0).


row_mult(M1,M2,Row,Result):- row_mult(M1,M2,Row,Result,1).
row_mult(M1,M2,Row, [H|T], C):-
	size(M2,_,Ncol),
	Ncol\=C,
	!,
	rowI(M1,Row,L1),
	columnJ(M2,C,L2),
	mult(L1,L2,H),
	C2 is C + 1,
	row_mult(M1,M2,Row, T,C2).

row_mult(M1,M2,Row, [H], C):-
	size(M2,_,Ncol),
	Ncol=C,
	rowI(M1,Row,L1),
	columnJ(M2,C,L2),
	mult(L1,L2,H).
	
product(M1,M2,R):- product(M1,M2,R,1).
product(M1,M2,[H|T],C):-
	size(M1,Nrow,_),
	Nrow\=C,
	!,
	row_mult(M1,M2,C, H),
	C2 is C + 1,
	product(M1, M2, T, C2).
	
product(M1,M2,[H],C):-
	size(M1,Nrow,_),
	Nrow=C,
	row_mult(M1,M2,C, H).



%5. traceMatrix(M, T)
%Input traceMatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]],R).
%Output R = 15;
%Explanation: created a function sum_list to sum the lists, and applied it on the code of the diagonal of the matrix.

sum_list([], 0).
sum_list([H|T], R) :-
  sum_list(T, R1),
  R is H + R1.

traceMatrix(X, Y):- diagonal(X,R,1), sum_list(R,Y).


%6 diagonal(M, D)
%Input diagonal([[1, 2, 3], [4, 5, 6], [7, 8, 9]],D).
%Output D = [1, 5, 9];
%Explanation: With a counter and the rowI function, always get the value on the following position for each row.

diagonal(X,R):- diagonal(X,R,1).
diagonal([],[],_).
diagonal(X,[R|Z],C):-
    X=[H|T],
    rowI(H,C,R),
    C1 is C+1,
    diagonal(T,Z,C1).
    
%7 identity(N, IM)
%Input identity(3,I).
%output: [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
%Explanation: Create ones function in order to give back a list with 0s and a 1 in a desired position.
	%After this, identity function calls ones with a counter until it reach the input to generate the desired matrix.

ones(X, Y, L):- ones(X, Y, L, 1).
ones(X ,Y, [0|R], C):-
	C\=X,
	C\=Y,
	C2 is C + 1,
	ones(X,Y,R, C2).
ones(X ,Y, [1|R], C):-
	C\=X,
	C=Y,
	C2 is C + 1,
	ones(X,Y,R, C2).
ones(X ,Y, [1], C):-
	C=X,
	C=Y.
ones(X ,Y, [0], C):-
	C=X,
	C\=Y.

identity(0,[[]]).
identity(1,[[1]]).
identity(X, R):- identity(X,R,1).
identity(X, [H|T],C):-
	X\=C,
	!,
	ones(X,C,H),
	C2 is C + 1,
	identity(X, T ,C2).
identity(X, [H],C):-
	ones(X,C,H).


%Exercise 6 Computation of the matrix transpose
%1. listFirst(M,LF)
%Input: listFirst([[1,2,8],[3,4],[5,6]],LF).
%output:LF = [1, 3, 5];
%Explanation: The function takes the head(element) of each head(list) and appends.
listFirst([],[]).
listFirst([H|T] , [H1|X]):-
	H = [H1|_],
	listFirst(T, X).
	
%2. listFollowers(M, LF)
%Input listFollowers([[1,2,8],[3,4],[5,6]],LF).
%output: LF = [[2, 8], [4], [6]];
%Explanation: The function takes the tail(element) of each head(list) and appends.

listFollowers([],[]).
listFollowers([H|T] , [T1|X]):-
	H = [_|T1],
	listFollowers(T, X).
	
%3. decompose(M, L1, L2)
%Input decompose([[1,2,8],[3,4],[5,6]], L1, L2).
%output
%Explanation: This has an efficient and inneficient way:
%The simple or inneficient was only to call the two previous functions.
%The efficient basically asks for the Head and Tail of each list, and append them in sepparate lists.

decompose([[X],[Y]],[X,Y],[]):-!.
decompose([], [], []).
decompose([[H|T]|T0], [H|L1], [T|L2]) :- 
	decompose(T0, L1, L2).

decompose1([],[],[]).
	decompose1(M, L1, L2):-
listFirst(M,L1),listFollowers(M,L2).
	
%4. transpose(M, R)
%Input transpose([[1,2],[3,4],[5,6]], R).
%Output L1 = [1, 3, 5] L2 = [[2, 8], [4], [6]];
%Explanation: For this the decompose function was used in order to convert the first elements (column) into a row.

transpose([[]|_], []).
transpose(M,[L1|Z]):-						
	decompose(M,L1,L2),
	transpose(L2,Z).
	
%transpose1([[]|_], []).	
%transpose1([H|T],[L1|R]):-    
%    decompose([H|T],L1,L2),
%    transpose1(L2,R).


